#!/bin/bash
# ______           _                      _       
# | ___ \         | |                    | |      
# | |_/ / __ _ ___| |__       _ __   ___ | |_ ___ 
# | ___ \/ _` / __| '_ \_____| '_ \ / _ \| __/ _ \
# | |_/ / (_| \__ \ | | |____| | | | (_) | | ' __/
# \____/ \__,_|___/_| |_|    |_| |_|\___/ \__\___|
#                                    by Maboroshy
#
# THIS SCRIPT COMES WITHOUT ANY WARRANTY
# ANY DAMAGE DONE TO YOUR FILES IS ALL YOUR FAULT

if [[ $1 = -h ]] || [[ $1 = --help ]]; then echo \
"Bash-note, version 0.3.0

Bash-note is as set of small scripts called modules which are supposed to help you 
and your note application or markdown editor managing plain text markdown syntax notes.

Bash-note stores its settings inside the script file in config section.

There are two types of modules: 
1) Modules evoked by file system watcher on specific file types.
Set the settings for them in config section and run bash-note as a file system watcher.

2) modules evoked by running bash-note with specific argument.
Run them with one of the command line arguments below.
Using more than one the arguments is not supported.

Usage:
bash-note                       Run file system watcher for directory set in config section
bash-note -w DIRECTORY          Run file system watcher for DIRECTORY

bash-note -d                    List and check module dependencies (binaries used in module)

bash-note -i FILE               Import bash-note settings from FILE

bash-note -c                    Add selected text or part of web page to a file set in config section
bash-note -c FILE               Add selected text or part of web page to FILE

bash-note -l                    Handle links in your notes with interactive menu
bash-note -l test               Run verbose test of link parser
bash-note -l t                  Same as above

bash-note -l list               Show list of all links by categories
bash-note -l l                  Same as above

bash-note -l cleanup            Clean media directory from files that are not linked to in notes
bash-note -l c                  Same as above
bash-note -l cleanup force      Clean media directory without confirmation
bash-note -l c f                Same as above

bash-note -l absolute           Convert all relative links to absolute
bash-note -l a                  Same as above
bash-note -l absolute force     Convert all relative links to absolute without confirmation
bash-note -l a f                Same as above
bash-note -l absolute test      Run verbose test of conversion. No notes will be modified.
bash-note -l a t                Same as above

bash-note -l relative           Convert all absolute links to relative
bash-note -l r                  Same as above
bash-note -l relative force     Convert all absolute links to relative without confirmation
bash-note -l r f                Same as above
bash-note -l relative test      Run verbose test of conversion. No notes will be modified.
bash-note -l r f                Same as above
"; exit; fi

# Don't change section markers with CAPS below or importing settings won't work.

#####################################################
# CONFIG SECTION: Set options for each module here. #
#####################################################

## General configuration ##
##-----------------------##

# Directory that stores notes or stores sub-directories with notes. 
# For QOwnNotes it is the one set in options and having "media" sub-directory for storing inline images.
note_root_dir="/storage/emulated/0/Android/data/com.ryeeeeee.markdownx/files/notes/Test"

# File extension which is considered as main note extension. Can be "md", "txt" or whatever. 
# Anyway script considers that there is markdown syntax inside it.
main_note_extension="md"

# Type of links Bash-note modules will generate while processing notes: "absolute" or "relative".
# QOwnNotes generates relative links but also handles absolute without issues.
# Most markdown editors won't work with relative links so use "absolute" or "nofile" if you need portability.
preferred_link_type="absolute"

# Put 1 to enable scanning all files before starting file system watcher. 
# That will process new files and changes that could have been made after previous Bash-note run.
scan_previous_changes_enabled=1

# Any CLI command bash-note should run before starting file system watcher. Leave empty for nothing.
# Can have absolute path otherwise will use bash-note file path. For example you can put 
# "bash-note -l cleanup force" to clean "media" directory at the start or a command to make a backup.
command_to_run_at_start=


## Notifications ##
##---------------##

### Duration of notifications in msec (1000 = 1 sec). Put 0 to disable notifications.
### Some events use short notifications that are half of set duration.
notifications_duration=4000

### Optional icons for notifications. Defaults are from KDE Plasma 5 Breeze icon set.
icon_success="emblem-success.svg"
icon_warning="emblem-warning.svg"


## Clipnote: pastes selected text to note ##
##----------------------------------------##

# Put inbox note file name here. Can have absolute path, otherwise file will be stored in note root directory.
clipnote_inbox_file_name="!Inbox.$main_note_extension"

# Entry sorting mode: newer_first or older_first
clipnote_sorting_mode=newer_first

# Put 1 to insert date and time before each entry 
clipnote_insert_date=1


## Web2note: converts web pages to markdown notes ##
##------------------------------------------------##

# Put 1 to enable, anything other do disable.
web2note_enabled=1

# Web page files directory appendix. Firefox and Chromium save linked files in "NAME_files" directory. 
# Don't name other directories like that or bad thing can happen to files there!
web_page_files_dir_app="_files"


## Fast notes merger: adds fast notes and images to a single main note ##
##---------------------------------------------------------------------##

# Put 1 to enable, anything other do disable.
fast_notes_merger_enabled=1

# Extension of files which are considered as "fast notes" and should be merged.
fast_notes_extension=txt

# Inbox directory. All "fast notes" and images put there will be added to inbox note.
fast_notes_merger_inbox_dir="$note_root_dir"

# Put inbox note file name here. Can have absolute path, otherwise will be stored in inbox directory. 
# Can be the same as for Clipnote module.
fast_notes_inbox_file_name="!Inbox.$main_note_extension"

# Entry sorting mode: newer_first or older_first
fast_notes_sorting_mode=newer_first

# Auto-rotate images to correctly display them if markdown editor doesn't support exif orientation.
# QOwnNotes is such markdown editor too. Requires jhead as a dependency.
fast_notes_auto_rotate_images_enabled=1


##########################################################################
# CODE SECTION: Don't change anything here... unless you really want to. #
##########################################################################

IFS=$'\n'

##==================##
## Shared Functions ##
##==================##

### Show notification: notify done|fail SUMMARY BODY
### There's a count mode that won't show notifications but count them to show a single one with numbers only.

notify () {
    if [[ $notifications_duration != 0 ]] && [[ $notifications_count_mode != 1 ]]; then
        [[ $1 = done ]] && notify-send -i "$icon_success" -t $notifications_duration "$2" "$3"
        [[ $1 = fast ]] && notify-send -i "$icon_success" -t $(($notifications_duration/2)) "$2" "$3"
        [[ $1 = fail ]] && notify-send -i "$icon_warning" -t $notifications_duration "$2" "$3"
    
    elif [[ $notifications_duration != 0 ]] && [[ $notifications_count_mode = 1 ]]; then
        [[ $1 = done ]] && (($n_done_notifications+1))
        [[ $1 = fast ]] && (($n_done_notifications+1))
        [[ $1 = fail ]] && (($n_fail_notifications+1))
    fi
} 

##===============================##
## Safety checks and preparation ##
##===============================##

### Get the real path of directories and files if they are symlinks. 
### Also cuts "/" in the end of paths so user can't really make a mistake by putting or not putting "/".
note_root_dir=$(realpath -q "$note_root_dir")
fast_notes_merger_inbox_dir=$(realpath -q "$note_root_dir")

### Set the "media" directory name and path according to link type and the name. With symlink fix.
media="media"
if [[ $preferred_link_type = "absolute" ]]; then
    media_path="$note_root_dir/$media"
    media_path=$(realpath -q "$media_path")
else media_path="$media"
fi

### Run command set in config.
if [[ -n $command_to_run_at_start ]]; then
    bash_note_file="$(realpath -s $0)"
    bash_note_path="${bash_note_file%/*}"
    cd "$bash_note_path"
    $command_to_run_at_start
fi

### Check if main note directory path contains special characters. If it does - notify and stop the script.
if [[ $note_root_dir = *[#\\\"]* ]] ; then 
    notify fail "Bash-note stopped: Bad note directory name" \
        "$note_root_dir contains special characters. Please rename note directory or higher level directories."
    exit
fi

### Check if main note directory is hidden. If it is - notify and stop the script.
if [[ $note_root_dir = */.* ]] ; then 
    notify fail "Bash-note stopped: Note directory is hidden" \
        "$note_root_dir is a hidden directory. Delete the leading dot for Bash-note to find it."
    exit
fi

## Clipnote: pastes selected text to note ##
##----------------------------------------##

if [[ $1 = -c ]]; then
    ### If there is a second command line argument, take it as inbox file name.
    [[ -n "$2" ]] && clipnote_inbox_file_name="$2"
    
    ### Check if inbox file and media directory for images exist, otherwise make them.
    cd "$note_root_dir"
    [ -f "$clipnote_inbox_file_name" ] || touch "$clipnote_inbox_file_name"
    mkdir -p "$note_root_dir/$media/Clipnote"
fi

## File system changes watcher modules ##
##-------------------------------------##

if [[ -z "$1" || $1 = "-w" ]]; then

    ## Fast notes merger: adds fast notes and images to a single main note ##
    ##---------------------------------------------------------------------##

    ### Check if "fast notes" extension is different from main notes extension. 
    ### That may save main notes from assembling into a single Devastator Note Prime.
    if [[ $fast_notes_merger_enabled = 1 ]] && [[ $main_note_extension = "$fast_notes_extension" ]]; then
        notify fail "Bash-note: Fast notes merger module stopped" \
        "Your main note extension - $main_note_extension is the same as fast notes extension."
        fast_notes_merger_enabled=0
    fi

    ### Check if fast notes merger inbox file and a directory to store images exist, otherwise make them.
    if [[ $fast_notes_merger_enabled = 1 ]]; then
        cd "$fast_notes_merger_inbox_dir"
        [ -f "$fast_notes_inbox_file_name" ] || touch "$fast_notes_inbox_file_name"
        mkdir -p "$note_root_dir/$media/ImageNotes"
    fi
fi

##====================================================##
## One-shot scripts called by commands line arguments ##
##====================================================##

## Dependencies checker: checks for binaries used in modules ##
##-----------------------------------------------------------##

### Function to check if binary present: check_command BINARY
check_command () { hash "$1" && echo "FOUND" || echo "NOT FOUND" ;}

if [[ $1 = -d ]]; then echo \
"Module dependencies:

DE notifications:
        libnotify           $(check_command notify-send)

File system watcher:
        inotify-tools       $(check_command inotifywait)
    
Clipnote:
        xclip               $(check_command xclip)
        gettext             $(check_command iconv)
        pandoc              $(check_command pandoc)
        wget                $(check_command wget)

Web2note:        
        gettext             $(check_command iconv)
        pandoc              $(check_command pandoc)

Fast notes merger:          
        jhead               $(check_command jhead)
"; exit; fi

## Settings importer: imports config from another bash-note file ##
##---------------------------------------------------------------##

if [[ $1 = -i ]] && [[ -n "$2" ]]; then

    ### Get all setting from config section of the old file.
    for setting_string in $(sed -n '/CONFIG SECTION: /,/CODE SECTION: /p' "$2" | grep -ve '#' -ve ^$); do

        ### Replace all setting in this file with setting existing in the old file. 
        ### If this (running) file have some new setting types - they stay.
        setting_name=${setting_string%=*}
        sed -i "s/^$setting_name.*/$setting_string/" "$(readlink -f "$0")"
    done

    [[ $? = 0 ]] && notify done "Bash-note: Settings imported" \
    "Settings from $2 imported to current script."
fi

## Clipnote: pastes selected text to note ##
##----------------------------------------##

if [[ $1 = -c ]]; then
    
    cd "$note_root_dir"
    
    ### Get clipboard content as html and convert it to markdown.
    IFS=
    clipnote_html="$(xclip -clip clip -t text/html -o || xclip -clip clip -t UTF8_STRING -o)"
    clipnote_url="$(xclip -clip clip -t text/x-moz-url-priv -o)"
    clipnote_md="$(printf '%s\n' "$clipnote_html" | iconv -sc -t utf-8 \
        | pandoc -f html -t markdown_strict+pipe_tables-raw_html)"

    IFS=$'\n'
    
    ### Get inline images links, even when their markdown code contains new lines.
 #    for img_link in $(printf '%s\n' "$clipnote_md" | sed -n "/^\!\[/,/)/p" \
 #     | grep -o 'http.*//[^ )]\+'); do

        for img_link in $(printf '%s\n' "$clipnote_md" | tr '\n' ' ' \
          | grep -o -e '!\[[^[]*] *([^)]*)' | grep -o -e 'http[^ )]\+'); do
 
        ### Download that images to media directory. 
        ### Adds some unique digits to file names to work around possible duplicates.
        img_name="${img_link##*/}"
        uniq=$RANDOM
        uniq_img_name="$uniq-$img_name"
        wget -q "$img_link" -O "$note_root_dir/$media/Clipnote/$uniq_img_name" &
        
        ### Replace links to online images with links to downloaded ones.
        clipnote_md=$(printf '%s\n' "$clipnote_md" \
            | sed "s|$img_link|file://$media_path/Clipnote/$uniq_img_name|g")
    done
    
    ### If it has a http link as the first line then it's a bookmark. 
    ### Get the web page title and format it all as entry. If there's no link make a simple text entry.
    if [[ $clipnote_md = http://* ]] || [[ $fast_note_text = https://* ]]; then
        bookmark_link="$(printf '%s\n' "$clipnote_md" | head -n1)"
        bookmark_title="$(wget -qO- "$bookmark_link" | grep -iPo '(?<=<title>)(.*)(?=</title>)')"
        [[ -n $bookmark_title ]] && entry=$(printf '%s\n' "[$bookmark_title]($bookmark_link)") \
          || entry=$(printf '%s\n' "<$bookmark_link>")
    else 
        entry=$(printf '%s\n' "$clipnote_md")
    fi
    
    ### Get the current date and time for a header. Add source link to header if url is available.
    if [[ $clipnote_insert_date = 1 ]]; then
        now_time=$(date '+%R %a %x')
        
        if [[ -n $clipnote_url ]]; then
            entry=$(printf '%s\n%s\n' "### $now_time [@]($clipnote_url)  " "$entry")
        else entry=$(printf '%s\n%s\n' "### $now_time  " "$entry")
        fi
    fi
    
    ### Add entry to the beginning or to the end of inbox note depending on chosen method.
    temp_file="$RANDOM"
    [ $clipnote_sorting_mode = newer_first ] && printf '%s\n\n' "$entry" \
        | cat - "$clipnote_inbox_file_name" > "$temp_file" && mv "$temp_file" "$clipnote_inbox_file_name"
    [ $clipnote_sorting_mode = older_first ] && printf '%s\n\n' "$entry" >> "$clipnote_inbox_file_name"
    
    ### Show notification. There is a function for that.
    notify fast "Selection saved to inbox note."
    exit
fi

## Relink: find and process links and linked files ##
##-------------------------------------------------##

if [[ $1 = -l ]]; then

### Get the list of all note files
declare -a note_files_list
note_files_list=( $(find "$note_root_dir" -not -path '*/.*' -name "*.$main_note_extension" -type f) )

### Get the list of all files in media directory
declare -a media_files_list
media_files_list=( $(find "$note_root_dir/$media" -type f) )

### Prepare arrays for all types of links known to Relink. Link can be in more than one list.
declare -A md_links_list
declare -A inline_image_links_list
declare -A reference_style_links_list
declare -A absolute_links_list
declare -A relative_links_list
declare -A no_leading_file_links_list
declare -A web_links_list
declare -A note_links_list

### Set regexp for reference-style links
reference_style_brackets='\[[^]]*]: *<[^>]*>'
reference_style_space='\[[^]]*]: *[^ ]* '

printf '%s\n\n' "Scanning notes..."

### Parse all links in all notes.
for note_file in ${note_files_list[@]}; do
    
    ### Print note file name in test mode. The bold way. 
    if [[ $2 = t ]] || [[ $2 = test ]]; then
        printf '\n\033[1m%s\033[0m' "FILE $note_file"
    fi
    
    ### Get any markdown link code. Truncating enables multi-line link code but doubles run time.
    for md_link in $(cat "$note_file" | tr '\n' ' ' \
      | grep -o -e '!\[[^[]*] *([^)]*)' -e '\[[^]]*] *([^)]*)' -e '\[[^]]*]: *<[^>]*>' -e '\[[^]]*]: *[^ ]* '); do
        
        ### Set link unique ID and put it to markdown links list 
        link_id=$((link_id+1))
        md_links_list["$link_id:$note_file"]="$md_link"
        file_link_type="#$link_id: "

        ### Get the link part. Use the special way for two types of refernce-style links. 
        ### If it's an inline image link "!" will stay before the file link.
        if [[ $md_link =~ $reference_style_brackets ]]; then
            file_link="$(printf '%s\n' "$md_link" | sed -n 's|\[.*]: *<\(.*\)>]*|\1|p')"
            file_link_type+='Reference-style, '
        elif [[ $md_link =~ $reference_style_space ]]; then
            file_link="$(printf '%s\n' "$md_link" | sed -n 's|\[.*]: *\(.*\)|\1|p')"
            file_link_type+='Reference-style, '
        else
            file_link="$(printf '%s\n' "$md_link" | sed -n 's|\[.*] *(\(.*\))|\1|p')"
        fi
        
        ### 1. If the starts with "!' clear "!" and mark as image link.
        [[ $file_link = "!"* ]] && \
          file_link="${file_link#\!}" && file_link_type+='Inline image, '
        
        ### 2. Clear from possible description in "" and spaces from the both sides
        file_link="${file_link%% \"*}"
        read -r file_link <<< "$file_link"
            
        ### 3. Clear leading "file:/", or put to appropriate list of it's not there 
        if [[ $file_link = file:/* ]]; then
            file_link="$(expr "$file_link" : 'file:/*\(.*\)')"
            file_link="/$file_link"
            file_link_type+='Has leading "file:/", '
        else
            no_leading_file_links_list["$link_id:$note_file"]="$file_link"
            file_link_type+='Missing "file:/" part, '
        fi
        
        ### Parse and put the link to appropriate list.
        [[ $file_link_type =~ image ]] \
          && inline_image_links_list["$link_id:$note_file"]="$file_link"
        [[ $file_link_type =~ Reference ]] \
          && reference_style_links_list["$link_id:$note_file"]="$file_link"
        [[ $file_link = http* ]] \
          && web_links_list["$link_id:$note_file"]="$file_link" && file_link_type+='Web link, '
        [[ $file_link = note* ]] \
          && note_links_list["$link_id:$note_file"]="$file_link" && file_link_type+='Note link, '
        
        if [[ -f $file_link ]]; then 
            absolute_links_list["$link_id:$note_file"]="$file_link"
            file_link_type+='Absolute.'
        elif [[ -f $note_root_dir$file_link ]]; then 
            relative_links_list["$link_id:$note_file"]="$file_link" 
            file_link_type+='Relative.'
        else
            file_link_type+="Not leading to a stored file."
        fi
        
        ### Show all the files and their links list in test mode.
        [[ $2 = t ]] || [[ $2 = test ]] && \
          printf '\n%s\n%s\n%s\n' "MD   $md_link" "LINK $file_link" "INFO $file_link_type"
    done
done

    ### If there's no command line argument given show scan summary and interactive menu.
    if [[ -z $2 ]]; then
        printf '%s\n\n%s\n' \
          "Bash-note scanned ${#note_files_list[@]} notes and found ${#md_links_list[@]} links." \
          "Among these links there are:"
          
        printf ' %-3s %s\n' \
          "${#inline_image_links_list[@]}" "inline image links" \
          "${#reference_style_links_list[@]}" "reference-style links" \
          "${#web_links_list[@]}" "links to web resourses" \
          "${#note_links_list[@]}" "links to other notes" \
          "${#absolute_links_list[@]}" "links with absolute path" \
          "${#relative_links_list[@]}" "links with relative path"
          
        printf '\n\n%s\n' 'Bash-note commands to handle links:'
        printf ' %-15s %s\n' \
          'l or list' 'to show list of all links with above categories' \
          'c or cleanup' 'to clean media directory from files that are not linked to' \
          'a or absolute' 'to convert all relative links to absolute with leading "file://"' \
          'r or relative' 'to convert all absolute links to relative' \
          'any other' 'to stop this script'
        
        printf '\n%s' 'Type command and press Enter > '
        read relink_command
    else
        relink_command="$2"
    fi
    
    ### List command: show list of all links by categories
    if [[ $relink_command = l ]] || [[ $relink_command = list ]] || [[ $2 = t ]] || [[ $2 = test ]]; then
        printf '\033[1m%s\n\033[0m%s\n\n' \
        "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _" "" \
        "Inline images links: ${#inline_image_links_list[*]}" "${inline_image_links_list[*]}" \
        "Reference-style links: ${#reference_style_links_list[*]}" "${reference_style_links_list[*]}" \
        "Links to other notes: ${#note_links_list[*]}" "${note_links_list[*]}" \
        "Absolute links: ${#absolute_links_list[*]}" "${absolute_links_list[*]}" \
        "Relative links: ${#relative_links_list[*]}" "${relative_links_list[*]}" \
        "Web resourses links: ${#web_links_list[*]}" "${web_links_list[*]}"
        
        ### Show scan time in test mode
        [[ $2 = t ]] || [[ $2 = test ]] && printf '\n%s\n\n' "The scan took:" && times
    fi
    
    ### Cleanup command: clean media directory from files that are not linked to.
    if [[ $relink_command = c ]] || [[ $relink_command = cleanup ]]; then
        
        declare -a media_files_to_delete
        for media_file in "${media_files_list[@]}"; do
       #     media_file="${media_file##*$media}"
            if [[ ! "${absolute_links_list[*]}" =~ $media_file ]] \
              && [[ ! "${relative_links_list[*]}" =~ ${media_file##*$note_root_dir} ]]; then
                media_files_to_delete+=( $media_file )
            fi 
        done
        
        ### Stop the script if there's nothing to cleanup.
        [[ ${#media_files_to_delete[@]} = 0 ]] \
          && printf '\n%s\n\n' 'No unused files found in "media" directory.' && exit
        
        ### Confirm
        if [[ ! $3 = f ]] && [[ ! $3 = force ]]; then
            printf '%s\n' '' "Files not linked to in any of your notes: ${#media_files_to_delete[@]}" \
              "${media_files_to_delete[@]}"
            printf '\n%s' 'Do you want to delete this files?' \
              'Type "y" to delete or anything else to abort > '
            read delete_confirmed
        else
            delete_confirmed=y
        fi
        
        ### Delete the file and delete the directory it is stored if it's empty.
        if [[ $delete_confirmed = y ]]; then
            for file_to_delete in ${media_files_to_delete[@]}; do 
                rm -f "$file_to_delete" && n_deleted=$(($n_deleted+1))
                rm -d "${file_to_delete%/*}"
            done
            printf '\n%s\n\n' "$n_deleted files deleted."
            [[ ${#media_files_to_delete[@]} != $n_deleted ]] \
              && printf '%s\n\n' "$((${#media_files_to_delete[@]} - $n_deleted)) files could not be deleted."
        fi
    fi

    ### Relative command: convert all absolute links to relative.
    if [[ $relink_command = r ]] || [[ $relink_command = relative ]]; then
        
        ### Confirm
        if [[ ! $3 = f ]] && [[ ! $3 = force ]] && [[ ! $3 = t ]] && [[ ! $3 = test ]] ; then
            printf '\n%s' "Do you want to convert ${#absolute_links_list[@]} links to relative?" \
              'Type "y" to convert, "t" for dry-run test or anything else to abort > '
            read convert_confirmed
        else
            [[ $3 = f ]] || [[ $3 = force ]] && convert_confirmed=y
            [[ $3 = t ]] || [[ $3 = test ]] && convert_confirmed=t
        fi
        
        ### Convert links and replace them in note files.
        if [[ $convert_confirmed = y ]] || [[ $convert_confirmed = t ]] \
          && (( ${#absolute_links_list[@]} > 0 )); then
            for id in ${!absolute_links_list[@]}; do
                
                ### Get note file name and convert link.
                note_file="${id#*:}"
                source_link="${absolute_links_list[$id]}"
                target_link="${source_link#$note_root_dir}"
                
                ### Replace the link or make verbose dry-run for test.
                if [[ $convert_confirmed = y ]]; then
                    
                    ### Make sure link have right leading "file:".
                    ### (file:/DIR - absolute,real size; file://DIR - relative; file:///DIR - absolute,scaled)
                    if [[ ${!no_leading_file_links_list[@]} =~ "$id" ]]; then
                        sed -i "/file:/! s|$source_link|file:/$target_link|" "$note_file" \
                          && n_converted=$(($n_converted+1))
                    else 
                        sed -i "s|file:/*$source_link|file:/$target_link|" "$note_file" \
                          && n_converted=$(($n_converted+1))
                    fi
                else 
                    printf '\n%s\n%s\n%s\n' "NOTE $note_file" "ABS  $source_link" "REL  $target_link"
                fi
            done
            
            ### Show summary or an empty line for a test run.
            if [[ $convert_confirmed = y ]]; then
                printf '\n%s\n\n' "$n_converted links converted."
                [[ ${#absolute_links_list[@]} != $n_converted ]] \
                  && printf '%s\n\n' "Conversion of $((${#relative_links_list[@]} - $n_converted)) links failed."
              
            else echo
            fi
        else 
            printf '\n%s\n\n' "No absolute links found."
        fi
    fi
    
    ### Absolute command: convert all relative links to absolute.
    if [[ $relink_command = a ]] || [[ $relink_command = absolute ]]; then
        
        ### Confirm
        if [[ ! $3 = f ]] && [[ ! $3 = force ]] && [[ ! $3 = t ]] && [[ ! $3 = test ]] ; then
            printf '\n%s' "Do you want to convert ${#relative_links_list[@]} links to absolute?" \
              'Type "y" to convert, "t" for dry-run test or anything else to abort > '
            read convert_confirmed
        else
            [[ $3 = f ]] || [[ $3 = force ]] && convert_confirmed=y
            [[ $3 = t ]] || [[ $3 = test ]] && convert_confirmed=t
        fi
        
        ### Convert links and replace them in note files.
        if [[ $convert_confirmed = y ]] || [[ $convert_confirmed = t ]] \
          && (( ${#relative_links_list[@]} > 0 )); then
            for id in ${!relative_links_list[@]}; do
                
                ### Get note file name without unique ID and convert link.
                note_file="${id#*:}"
                source_link="${relative_links_list[$id]}"
                target_link="$note_root_dir$source_link"
                
                ### Replace the link or make verbose dry-run for test.
                if [[ $convert_confirmed = y ]]; then
                    
                    ### Make sure link have right leading "file:". 
                    ### (file:/DIR - absolute,real size; file://DIR - relative; file:///DIR - absolute,scaled)
                    if [[ ${!no_leading_file_links_list[@]} =~ "$id" ]]; then
                        sed -i "s|$source_link|file://$target_link|" "$note_file" \
                          && n_converted=$(($n_converted+1))
                    else 
                        sed -i "s|file:/*$source_link|file://$target_link|" "$note_file" \
                          && n_converted=$(($n_converted+1))
                    fi
                else 
                    printf '\n%s\n%s\n%s\n' "NOTE $note_file" "REL  $source_link" "ABS  $target_link"
                fi
            done
            
            ### Show summary or an empty line for a test run.
            if [[ $convert_confirmed = y ]]; then
                printf '\n%s\n\n' "$n_converted links converted."
                [[ ${#relative_links_list[@]} != $n_converted ]] \
                  && printf '\n%s\n\n' "Conversion of $((${#relative_links_list[@]} - $n_converted)) links failed."
              
            else echo
            fi
        else 
            printf '\n%s\n\n' "No relative links found."
        fi
    fi
    
    exit
fi
        
##==========================================================================##
## File watcher loop: gets changed files and pulls them through all modules ##
##==========================================================================##
        
## File system changes watcher ##
##-----------------------------##

if [[ $1 = -w ]] && [[ -n "$2" ]]; then note_root_dir="$2"; fi

### Scan all files excluding hidden directories/files and "media" directories to process everything 
### that could have changed before previous bash-note run. After that get all the file system events.
( 
    if [[ $scan_previous_changes_enabled = 1 ]]; then 
        notifications_count_mode=1
        find "$note_root_dir" ! -path '*/.*' ! -path "$note_root_dir/$media/*" -type f
        notifications_count_mode=0
        
        # TODO
#         (( $n_done_notifications > 0 )) && summary+="$n_done_notifications events processed."
#         (( $n_fail_notifications > 0 )) && summary+="Failed to process $n_fail_notifications events."
#         [[ -n $summary ]] && notify-send -t $notifications_duration "Bash-note" "$summary"
    fi
    sleep 1
    inotifywait -mrq -e modify -e move --format '%w%f' \
    --exclude "(.*/\..|$note_root_dir/$media/)" "$note_root_dir"

)   | while read -r file; do

### Check if there are special symbols in file name or path which will break bash. Notify if true.
if [[ $file = *[#\\\"]* ]] ; then 
    notify fail "Bash-note: Bad file name" \
      "$file_name contains special symbols and won't be processed by Bash-note."
    continue 
fi

### Check if the file is there or skip it.
[[ -f "$file" ]] || continue 

### Parse all the file data checked by modules.
file_path="${file%/*}"
file_name="${file##*/}"
file_ext="${file_name##*.}"
file_mime="$(file -ib "$file")"


## Web2note: converts web pages to markdown notes ##
##------------------------------------------------##

if [[ $web2note_enabled = 1 ]] && [[ ! $file_path =~ "$web_page_files_dir_app" ]] \
  && [[ $file_ext != "$main_note_extension" ]] && [[ $file_mime =~ text/html ]] ; then
    
    ### Wait for browser to check that file is downloaded.
    sleep 1
    
    ### Convert web page to html-less markdown with main note extension.
    iconv -sc -t utf-8 "$file" \
      | pandoc -f html -t markdown_strict+pipe_tables-raw_html -o "${file%.*}"."$main_note_extension"
    
    ### Put "file://media/" before every image link, even if image tag is multi-line. 
    ### Images will be put to media directory in the next loop.
    img_link=$(cat "${file%.*}"."$main_note_extension" | tr '\n' ' ' \
      | grep -o -e '!\[[^[]*] *([^)]*)' | grep -m 1 "$web_page_files_dir_app")
    img_link_path=${img_link#*(}
    img_link_path=${img_link_path%%$web_page_files_dir_app*}
            
    sed -i "s|($img_link_path|(file://$media_path/$img_link_path|g" "${file%.*}"."$main_note_extension"
     
    ### Check if new note file is there. Show notification and remove converted web page.
    if [[ -f "${file%.*}"."$main_note_extension" ]]; then 
        notify done "Bash-note: Web page converted" "${file_name%.*} converted to note"
        rm "$file" 
    else notify fail "Bash-note: Web page conversion failed" "${file_name%.*} conversion failed"
    fi
fi &

if [[ $web2note_enabled = 1 ]] && [[ $file_path =~ "$web_page_files_dir_app" ]] ; then
    
    ### Get the relative path of the file beginning with DIRECTORY_files. 
    web_page_files_dir_name="${file_path%%$web_page_files_dir_app*}"
    web_page_files_dir_name="${web_page_files_dir_name##*/}"
    web_page_files_subdir="${file_path##*$web_page_files_dir_app}"
    web_page_files_relative_path="$web_page_files_dir_name$web_page_files_dir_app$web_page_files_subdir"
    
    ### Wait for browser to check that file is downloaded.
    sleep 1
    
    ### Move image files to the same directory in media.
    if [[ $file_mime =~ image ]]; then
        mkdir -p "$note_root_dir/$media/$web_page_files_relative_path"
        mv -f "$file" "$note_root_dir/$media/$web_page_files_relative_path/"
        
    ### Or delete them if they are not images.
    else rm -f "$file"
    fi
    
    ### Try to delete empty source directory. Last file will finally do this.
    rm -d "$file_path"
fi &
    
## Fast notes merger: adds fast notes and images to a single main note ## TODO Make write buffer
##---------------------------------------------------------------------##

if [[ $fast_notes_merger_enabled = 1 ]] && [[ $file_path = "$fast_notes_merger_inbox_dir" ]] \
  && [[ $fast_notes_extension = "$file_ext" || $file_mime =~ image ]]; then
    
    cd "$fast_notes_merger_inbox_dir"
    
    ### Get the file modification date and time for a header.
    mod_time=$(date '+%R %a %x' -r "$file")
 
    ### If it's and image then format it as entry and move it to media directory. 
    ### If it's not then get the content and delete it.
    if [[ $file_mime =~ image ]]; then 
        entry=$(printf '%s\n%s\n' "### $mod_time  " "![](file://$media_path/ImageNotes/$file_name)")
        [[ $fast_notes_auto_rotate_images_enabled = 1 ]] && jhead -se -exonly -autorot "$file"
        mv -f "$file" "$note_root_dir/$media/ImageNotes"
    else 
        fast_note_text="$(cat "$file")"
        rm -f "$file"
    fi
    
    ### If it has a http link as the first line then it's a bookmark. 
    ### Get the web page title and format it all as entry. If there's no link make a simple text entry.
    if [[ $fast_note_text = http://* ]] || [[ $fast_note_text = https://* ]]; then
        bookmark_link="$(printf '%s\n' "$fast_note_text" | head -n1)"
        bookmark_title="$(wget -qO- "$bookmark_link" | grep -iPo '(?<=<title>)(.*)(?=</title>)')"
        [[ -n $bookmark_title ]] && entry=$(printf '%s\n%s\n' "### $mod_time  " "[$bookmark_title]($bookmark_link)") \
          || entry=$(printf '%s\n%s\n' "### $mod_time  " "<$bookmark_link>")
        
    else 
        entry=$(printf '%s\n%s\n' "### $mod_time  " "$fast_note_text")
    fi

    ### Add entry to the beginning or to the end of inbox note depending on chosen method.
    temp_file="$RANDOM"
    [ $fast_notes_sorting_mode = newer_first ] && printf '%s\n\n' "$entry" \
        | cat - "$fast_notes_inbox_file_name" > "$temp_file" && mv "$temp_file" "$fast_notes_inbox_file_name"
    [ $fast_notes_sorting_mode = older_first ] && printf '%s\n\n' "$entry" >> "$fast_notes_inbox_file_name"
    notify fast "Bash-note: Fast note added" "$file_name added to inbox note"
fi &

done ### It's the final "done" of file watcher loop.
